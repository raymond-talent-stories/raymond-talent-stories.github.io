---
layout:     post
title:      ANGULAR核心 - 依赖注入
subtitle:   深入理解Angular的依赖注入机制及其在开发中的应用
date:       2024-11-28
author:     Raymond Zhang
header-img: https://images.ctfassets.net/s600jj41gsex/2T9SRFBlKsWAuFrOFm2YQR/1a4843866b0cf3642e355e17a332e03a/toptal-blog-image-1518187252525-03f6db7b1c131066061024c236c7e3ff-1024x536.png?w=1024&h=536&q=50&fm=webp&fit=scale
catalog:    true
filter:     brightness(0.24)
tags:
    - Angular
    - Frontend
images:
    image1: 
---

> 依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（`DI`）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们。
## 为什么需要依赖注入
软件开发原则的实质是实现低耦合系统，在面向对象编程方面，类`class`的初始化取决于构造函数的实现，而构造函数的参数往往可变的。比如：

```typescript
class MyService {
    constructor(public name: string, public value: string) {

    }
    doSomething() {

    }
}
```

在另一个模块中调用`MyService`:

```typescript
class YourService {
    myService: MyService
    constructor() {
        this.myService = new MyService('name', 'value')
    }
}
```

假如`MyService`的构造函数发生了变化，那么`YourService`必然需要做适当的调整，那么，`MyService`和`YourService`的耦合有没有办法解决呢？
## 依赖注入
在`Angular`中，我们通常可以通过下面的代码实例化`MyService`：

```typescript
class YourService {
    constructor(public myService: MyService) {
        // this.myService
    }
}
```

优化后的代码只需要在构造函数中声明`MyService`，而不再需要执行实例化相关的逻辑，便可以实现同样的效果。而且，`YourService`不再依赖于`MyService`中的构造函数的参数，那么`name`和`value`如何传递给`myService`对象呢？我们需要改造下`MyService`：

```typescript
import { Inject, Injectable } from '@angular/core'

@Injectable()
class MyService {
    constructor(@Inject('name') public name: string, @Inject('value') public value: string) {

    }
    doSomething() {

    }
}
```

在`Angular`中我们利用了`@Inject`这个装饰器，`name`和`value`变成了外部的依赖项，比如我们可以在统一事务中提供`MyService`依赖的参数：

```typescript
import { ApplicationConfig } from '@angular/core'

const appConfig: ApplicationConfig = {
  providers: [
    { provide: 'name', useValue: 'Raymond' },
    { provide: 'value', useValue: 'SecretKey-xxx' }
  ]
};
```

那么，此模块下的所有针对`MyService`的引用将自动使用上述提供者的值作为参数。

## 原理